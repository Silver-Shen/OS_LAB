#OS Lab8 Report

##练习1:完成读文件操作的实现
####1.分析与实现
>主要需要完成的函数为sfs_io_nolock，这个函数是具体的文件系统SFS对磁盘的读写，给定要读写的文件的inode和偏移量以及读取的长度，sfs_io_nolock会将磁盘上的数据块中的数据读入内存中指定的缓存区内，并返回实际读写的长度。
>首先我们根据读写标志动态绑定处理函数，然后分三段来处理。第一段是开头那一块不按块对齐的内容，第二段是对齐的整数块数据块，第三段是结尾不对齐的数据，重要的函数为sfs_bmap_load_nolock（用于根据块号查找数据块index），sfs_block_op（具体的读写操作）

####2.“UNIX的PIPE机制”的概要设方案
>管道是用于两个进程间通信的手段，UNIX的PIPE描述如下：`管道是由内核管理的一个缓冲区，相当于我们放入内存中的一个纸条。管道的一端连接一个进程的输出。这个进程会向管道中放入信息。管道的另一端连接一个进程的输入，这个进程取出被放入管道的信息。一个缓冲区不需要很大，它被设计成为环形的数据结构，以便管道可以被循环利用。当管道中没有信息的话，从管道中读取的进程会等待，直到另一端的进程放入信息。当管道被放满信息的时候，尝试放入信息的进程会等待，直到另一端的进程取出信息。当两个进程都终结的时候，管道也自动消失。`在ucore中，由于我们已经实现了文件系统抽象层-VFS，故我们可以把管道也实现成一个特殊的文件，我们可以在内存中虚拟一个VFS的索引节点inode，但这个inode并不指向实际文件系统的索引节点，而是指向一块物理内存区域（比如大小为4K的一页）作为管道通信的场所，然后让绑定这个管道的两个进程的文件描述队列中的file结构都指向这个inode，重载一下文件的读写操作并动态绑定给这个VFS inode之后，我们就可以利用平常的read/write系统调用像文件一样操作管道了。


---

##练习2:完成基于文件系统的执行程序机制的实现
####1.分析与实现
>这个部分需要完成的是load_icode函数，这个函数在do_execve函数中被调用，主要完成将磁盘中的程序加载进内存，并初始化一些资源让其成为进程的过程。load_icode主要分为七个部分，其中有两个部分和前面的实验有比较明显的区别，一个是讲代码和数段从磁盘加载进内存，另一个是在用户栈上准备进程所需要的参数。主要通过调用load_icode_read进而调用访问文件的系统调用接口进行文件的读写。

####2.基于”UNIX的硬链接和软链接机制“的概要设方案
>硬链接的实现方案是使得新创建的链接文件和原文件共享同一个inode，并增加inode的链接计数；软连接的话则新建一个inode，并在inode的数据块中存放需要链接的文件的路径名。

---
##与参考答案实现上的区别
####练习一
>没有太大的区别

####练习二
>没有太大的区别

---
##实验原理（重要部分简析）
###实验中涉及的原理
####1.SFS文件系统的布局
>SFS文件系统中以block(4K，与内存 page 大小相等）为基本单位；`第0个块（4K）是超级块（superblock），它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存；第1个块放了一个root-dir的inode，用来记录根目录的相关信息，通过这个root-dir的inode信息就可以定位并查找到根目录下的所有文件信息；从第2个块开始，根据SFS中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况。这个区域称为SFS的freemap区域；最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息。`

####2.文件系统的访问处理过程
>应用程序操作文件（打开/创建/删除/读写），首先需要通过文件系统的通用文件系统访问接口层给用户空间提供的访问接口进入文件系统内部，接着由文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统），具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。