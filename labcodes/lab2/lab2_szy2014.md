#OS Lab2 Report

##练习1：实现 first-fit 连续物理内存分配算法
####1.设计思路
>first-fit算法的主要思想是顺序遍历可用的内存块（可能包含多页），找到第一块符合大小的内存块，分配给需要的页数，如果有多余就切下剩余的块作为新的内存块，回收时检查有没有相邻的空闲块，有就合并。

####2.实现过程
 1. init:这部分比较简单，直接复用默认的实现，初始化一个空的空闲块列表即可
 2. init_memmap:需要修改默认的实现，核心点是first-fit需要将空闲内存块按照物理地址的大小顺序排列，故在构造链表时应该将每次探测到的空闲块插入到链表尾部
 3. alloc_pages:从空闲块链表头结点依次往后遍历，找到第一块就停下来，修改Property标记位，把此空闲块从链表中删除，如果有多余的页就新构造一个空闲块，插入原位置（注意只有插入原位置才能保证物理地址是递增的）
 4. free_pages:首先将base开始的连续n页物理页标志位全部清空，然后遍历整个空闲块链表，查看是否有可以合并的块，如果有就合并（并把原先在链表中待合并的块删除），遍历链表将合并后的新块插入合适的位置（物理地址递增）
 
####3.改进空间
>算法的大致框架基本是确定的，可改进的部分在于free_pages，目前的实现是遍历空闲块链表找到相邻块后先把它从链表删除，和要释放的块合并后再插回去，这样就导致了一次“额外”的遍历，如果能就地进行插入的话效率可能会更高，不过需要考虑同时两边都有相邻块的问题。<br>
`还有一点是first-fit每次都从地址最小开始分配，可能会导致低地址的块被切得很碎，从整体性能上可以考虑从上次分配完的地址开始搜索。`

---
##练习2：实现寻找虚拟地址对应的页表项
####1.设计思路
>练习2的注释中将整个实现的思路描述得比较完整，大体上按照上面来就不会有问题，get_pte函数主要完整一级页目录表的填写和二级页表的建立，过程中可能会遇到二级页表还不存在需要分配页的问题，这就需要调用alloc_page，也就是练习一实现的功能，从这个角度上看整个lab2的练习是环环相扣的。在建立好二级页表之后，需要填写页目录表项完成映射。如果二级页表已经存在，直接返回对应的表项即可。这个过程中需要掌握正确的虚拟地址映射关系，也就是如下这个结构：

```
// A linear address 'la' has a three-part structure as follows:
//
// +--------10------+-------10-------+---------12----------+
// | Page Directory |   Page Table   | Offset within Page  |
// |      Index     |     Index      |                     |
// +----------------+----------------+---------------------+
//  \--- PDX(la) --/ \--- PTX(la) --/ \---- PGOFF(la) ----/
//  \----------- PPN(la) -----------/
```
>只要正确把握了这个结构，实现起来还是比较容易的。

####2.实现过程
  1. 定位页目录表项：通过pgdir+PDX(la)实现
  2. 查看对于二级页表是否存在（与上PTE_P）
  3. 若不存在，调用alloc_page，转4，否则转6
  4. 清空分配的页面，正确设置引用计数
  5. 设置对应的页目录表项，正确映射二级页表(pt_p & ~0x0FFF) | PTE_U | PTE_W | PTE_P（pt_p为二级页表的物理地址）
  6. 计算Page Table Index,返回对应表项

####3.请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。
>页目录项的结构如下

```
  PT19 ... PT0|Reserved(3bit)|0|PSE|0|A|PCD|PWT|U/S|W/R|P
```
最高20位为页表物理地址的高20位（因为页表地址按页对齐），最低位P表示是否存在对应页表，W/R表示可读可写性质，U/S表示权限，A表示是否被访问
>页表的结构如下

```
  PFN19 ... PFN0|Reserved(3bit)|0|D|0|A|PCD|PWT|U/S|W/R|P
```
控制位和页目录项大体一致，但增加了一位D表示该页是否被修改。最高二十位为对应物理页的页号，也即物理页的最高二十位
`控制位对ucore来说很有用，P位可以指示是否发生缺页异常，A和D可以用在页面调度策略上（即缺页时需要换出一部分页面），比如最近被访问的页面我不把它换出去，这时A位就有用；又比如我把页面换出去时要看看D位是否为1，如果为1那么需要写回`

####4.如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情
>首先硬件要记录当前执行的上下文信息，然后判断是哪种异常。如果是页缺失，那么就调用页缺失的中断服务例程将页面换入；如果访问了非法内存，比如超过了段偏移（实际好像不会发生这种情况），那么要及时报错

---
##练习3：释放某虚地址所在的页并取消对应二级页表项的映射
####1.设计思路
>基本按照注释的步骤进行，首先判断页表项对应的物理页是否存在，存在的话修改引用计数并在适当时候释放物理页（没有虚拟地址引用了），还需要修改tlb

####2.实现过程
  1. 判断表项对应物理页是否存在 (*ptep) & PTE_P
  2. 若不存在，直接返回，否则转3
  3. 通过页表项得到对应的物理页管理结构page pte2page(*ptep)
  4. 修改引用计数，如果发现为0了调用free_page
  5. 删除tlb对应的缓存，清零页表项
  
####3.数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥
>两者有间接的对应关系，这种对应关系只有在页表项映射了实际的物理页才会建立。页表项中存储了对应物理页的页号（也即物理地址高20位），这个页号同时也是相应的page在pages数组中的index,因为物理页和page结构体是一一对应的。

####4.如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ 鼓励通过编程来具体完成这个问题
>需要修改整个ucore的内存布局，即把虚拟的可用内存空间从0xC0000000~0xF8000000平移到0x0~0x38000000
具体步骤如下:<br>
 1.修改kernel.ld,将链接地址偏移

```
/* Load the kernel at this address: "." means the current address */
    . = 0x00100000;  
```
> 2 修改memlayout中的内存布局

```
/* All physical memory mapped at this address */
#define KERNBASE            0x00000000
#define KMEMSIZE            0x38000000                  // the maximum amount of physical memory
#define KERNTOP             (KERNBASE + KMEMSIZE)
#define VPT                 0x3AC00000
```
> 3 在pmm.c中防止对页目录第一项的修改(即boot_pgdir[0])

```
//boot_pgdir[0] = 0; 所有对第一项置零的语句都注释
```

>修改后的输出的页表项如下

```
-------------------- BEGIN --------------------
PDE(0e0) 00000000-38000000 38000000 urw
  |-- PTE(38000) 00000000-38000000 38000000 -rw
PDE(001) 3ac00000-3b000000 00400000 -rw
  |-- PTE(000e0) 3ac00000-3ace0000 000e0000 urw
  |-- PTE(00001) 3aceb000-3acec000 00001000 -rw
--------------------- END ---------------------
```
成功实现了虚拟地址和物理地址的对等映射

---
##与参考答案实现上的区别
####练习一
>参考答案在管理内存的规模上是`以页为单位`的，它把每一个空闲页对应的Page都添加到了空闲块链表中；而我的实现中是`以块为单位`的，一块连续的空闲页只有起始页加入链表，在分配和释放时搜索效率会高很多

####练习二
>实现上没有太大的区别

####练习三
>实现上没有太大的区别

---
##实验原理（重要部分简析）
###实验中涉及的
####1.页式内存管理
>操作系统和应用程序都需要内存空间来存放代码和数据，这要求操作系统能够高效管理和保护整个计算机中的物理内存，并给自己和上层应用提供简洁安全的内存申请和释放的服务接口。通过分段机制可以完成虚拟地址到线性地址的转换，而通过分页机制可以进一步完成线性地址到物理地址的转换。分段机制中对每段的大小是可变的，分页机制中页的大小固定为4KB，这样在操作系统对实现内存管理上会更加简洁。`实验中对页式内存管理进行了细化，并且考虑了在实际机器上实现页式内存管理所特有的实际问题（比如可用空间探测，按页对齐可用空间等等`

####2.内存分配算法
>在原理课中，老师讲了连续内存分配的算法，比如first fit, best fit, worst fit和buddy system等等，`实验中将这些算法结合到了非连续内存分配，也就是页式内存管理。在页式管理中，将连续的内存块下限设为4kb，并在连续的一块空闲页构成的空闲块层次上实现内存分配算法`

####3.页表和多级页表
>原理课上讲过，由于80x86的地址空间可达到4GB，按页大小（4KB）划分为1M个页。如果用一个页表来描述这种映射，那么该也表就要有1M个表项，若每个表项占用4个字节，那么该映射表就要占用4M字节。`考虑到将来一个进程就需要一个地址映射表，若有多个进程，那地址映射表所占的总空间将非常巨大`。为避免地址映射表占用过多的内存资源，80x86把地址映射表设定为两级。地址映射表的第一级称为页目录表，存储在一个4KB的物理页中，页目录表共有1K个表项，其中每个表项为4字节长，页表项中包含对应第二级表所在的基地址。地址映射表的第二级称为页表，每个页表也安排在一个4K字节的页中，每张页表中有1K个表项，每个表项为4字节长，包含对应页帧的基地址。`在实验中，ucore也沿用了这个机制，虽然ucore实际支持的内存空间不到1G，还但是使用了二级页表来组织整个页式内存管理`

---
###实验中未涉及的
####1.MMU以及高速缓存
>原理课中提到，内存管理单元在控制内存的访问过程中会先查询Cache来提高内存访问的速度，也就是操作系统会把内存中一些可能近期会访问的数据缓存在cache中，`判断把什么数据或者代码装入cache对于提高系统性能也是至关重要的`。

####2.反置页表
>原理课中提到，当系统位宽来到64位，地址空间进一步增大之后，多级页表也不能很好的适应这样大的寻址空间，`虚拟空间和物理空间的差异被进一步放大,这种时候，反置页表由于只和物理地址大小有关变得很有优势，如果结合良好的哈希操作，能够大大减少页表所占的空间和提高访存性能。`