#OS Lab5 Report

##练习1：加载应用程序并执行
####1.设计思路
>这个练习的主要目标是设置好用户程序在中断返回所需要用到的异常帧，以便能够从中断中正确地返回并执行。由于这是第一个用户程序，故我们其实是将其“硬”构造出来的，回顾lab1的challenge我们可以知道，要在用户态下正确执行，需要设置好cs,ds,es,ss,eip等段寄存器和指令指针，故我们一一将其设置即可。

####2.实现过程

```
1.设置代码段寄存器为用户代码段 tf->tf_cs = USER_CS;
2.设置数据段和堆栈段为用户数据段 tf->tf_ds = tf->tf_es = tf->tf_ss = USER_DS;
3.设置用户程序的用户态堆栈 tf->tf_esp = USTACKTOP;
4.设置进程的指令寄存器 tf->tf_eip = elf->e_entry;
5.设置eflags使得在用户态能够响应中断 tf->tf_eflags |= FL_IF;
```
 
####3.描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的
>其实在执行加载之前，我们已经在运行一个进程了，这个进程就是之后将要加载的应用程序的壳，当执行加载的系统调用之后，我们把新的程序加载进来覆盖掉所有的内存，然后最关键的一步就是中断返回，这恰好是练习一的主要内容，我们在加载的时候已经正确设置了异常帧，其中的tf_eip已经指向了新的程序的代码起始位置，故我们在返回时借由iret就可以跳转到新的程序的第一行并开始执行了。


---
##练习2：父进程复制自己的内存空间给子进程
####1.设计思路
>当父进程创建字进程时，需要复制自己的内存空间给子进程，这最终是通过调用copy_range实现的，copy_range的任务很简单，它输入两个页目录表，并根据起始和结束位置把一张表中的内容复制到另一张表上，那么我们只需要为新的进程不断分配页面，并把父进程的内存memcpy过来就行了。

####2.实现过程
>通过get_pte找到父进程页目录表中的页表项，并在子进程页目录表中创建二级页表（若需要），然后遍历原进程所有合法内存（按页为单位），依次进行复制，并建立正确的映射关系，实现如下

```
	char* src_kvaddr = page2kva(page);
	char* dst_kvaddr = page2kva(npage);
   	memcpy(dst_kvaddr, src_kvaddr, PGSIZE);
    ret = page_insert(to, npage, start, perm);
    assert(ret == 0);
```

####3.简要说明如何设计实现"Copy on Write 机制"
>要实现COW的话，我们就不能在创建进程时将父进程的所有内存都复制过去，而是要实现“临时的共享”。具体来说，我们可以将子进程的页目录表中的表项直接指到父进程的页目录表项，这样就“粗暴”地实现了内存共享，但此外我们要把原来可写的页表项置位不可写，等到写时会触发页异常。等待触发了写异常，我们就检查是否是由于COW造成的，如果是，那么我们就为写的那个进程复制一份页面，然后替换掉原先的页目录项和页表项，并设置页表项可写。

---

##练习3：阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现
####1.
>fork最终由内核函数do_fork来实现，do_fork首先创建进程控制块，然后为进程分配内核堆栈并复制父进程的内存空间和上下文信息，如果这些操作都成功那么就分配一个唯一的pid并加入进程队列，唤醒它；exec最终由内核函数do_execve实现，首先清理原进程的内存，然后调用load_icode将新应用程序代码加载进内存，设置好返回的异常帧；wait函数最终由do_wait实现，do_wait首先查找有没有已经退出的子进程，如果有就返回了，如果都未结束，那么挂起自身等待子进程结束；exit首先清理自己的内存环境，然后查看是否有父进程在等待自己，最后过继自己的子进程给进程链上方的进程们。`系统调用本质还是通过中断来实现的，用户程序可以手动触发一个系统调用中断，这在用户库最底层是通过内联汇编实现的，然后内核的trap会捕获这个编号，并通过dispatch来调用内核态的syscall，根据调用号的不用最终落实到上述的do_fork/do_wait等`

####2.请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的
>fork会把子进程加入就绪队列，exec不改变进程的运行状态（前提是没有手动要求调度或时间片到）但改变了进程执行的内容（代码变了），wait可能会将自身转变为等待态（如果没有子进程已经返回），exit会将自身转为退出态

####3.请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）
```
process state changing:

  alloc_proc                                 RUNNING
      +                                   +--<----<--+
      +                                   + proc_run +
      V                                   +-->---->--+ 
PROC_UNINIT -- proc_init/wakeup_proc --> PROC_RUNNABLE -- try_free_pages/do_wait/do_sleep --> PROC_SLEEPING --
                                           A      +                                                           +
                                           |      +--- do_exit --> PROC_ZOMBIE                                +
                                           +                                                                  + 
                                           -----------------------wakeup_proc----------------------------------
```

---
##与参考答案实现上的区别
####练习一
>没有太大的区别

####练习二
>没有太大的区别

---
##实验原理（重要部分简析）
###实验中涉及的原理
####1.程序在用户态的运行
>这其实是lab1 challenge的正式版，在那里我们仅仅是测试了一下，而在lab5中我们需要为用户态进程建立完整的生态环境。首先便是内存，用户态有自己的虚拟内存空间，和内核空间是隔离的，这样能做到所有进程共享一份内核代码；其次要建立好中断返回的上下文环境，正确设置段寄存器，特别是cs（因为中断返回时是通过cs来判断你的执行特权级的）。

####2.系统调用
>系统调用在中断表中是占有一个位置的，但它是一个特殊的中断，因为它可以在用户态触发；ucore在用户态封装了很多系统调用函数，这些函数无一例外最终是通过内联汇编直接触发系统调用的中断来实现的，然后内核的中断处理函数会捕获到系统调用，并调用其服务例程，然后在那个服务例程中又根据你的系统调用号进一步做了分类，相当于两级服务例程的嵌套。