#OS Lab3 Report

##练习1：给未被映射的地址映射上物理页
####1.设计思路
>在发生缺页异常的时候，如果虚拟地址对应的页表项中没有分配的物理页面（同时物理页面也不在磁盘中），这时就需要给它映射上物理页。主要的方法是先为其分配一个物理页面，然后填写相应的页表项，异常返回之后重新执行当前的指令即可。

####2.实现过程
 1. 通过get_pte获取虚拟地址对应的页表项
 2. 判断页表项是否为空，如果是就需要分配物理页
 3. 通过pgdir_alloc_page分配物理页面
 
####3.描述页目录项（Pag Director Entry）和页表（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处
>页目录项的结构如下

```
  PT19 ... PT0|Reserved(3bit)|0|PSE|0|A|PCD|PWT|U/S|W/R|P
```
最高20位为页表物理地址的高20位（因为页表地址按页对齐），最低位P表示是否存在对应页表，W/R表示可读可写性质，U/S表示权限，A表示是否被访问
>页表的结构如下

```
  PFN19 ... PFN0|Reserved(3bit)|0|D|0|A|PCD|PWT|U/S|W/R|P
```
控制位和页目录项大体一致，但增加了一位D表示该页是否被修改。最高二十位为对应物理页的页号，也即物理页的最高二十位
`控制位对ucore来说很有用，A和D分别表示访问位和修改位，在实现时钟算法和改进的时钟算法时，会用到这两个标志位`

####4.如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
>如果缺页服务例程发生了访问异常，硬件首先要保存现场的上下文信息，然后禁止嵌套中断，因为一般的流程是缺页时由缺页服务例程来处理，但此时由于缺页服务例程也缺页，故需要事先约定好服务例程的对换区地址，由硬件将其加载进内存。

---
##练习2：补充完成基于FIFO的页面替换算法
####1.设计思路
>先进先出算法只考虑页面第一次被访问的时间，故我们可以将ucore访问的物理页按照分配的顺序串成一条链表，其中表头为最先访问的，表尾为最后访问的；在需要换出页面时，将表头的页面换出即可

####2.实现过程
 1. 当有新访问的页面时，将其加入链表的尾部list_add_before(head, entry);
 2. 当需要换出页面时，将表头删除list_del(list_next(head));
 
####3.extended clock页替换算法
>我认为当前的ucore中的swap_manager框架足够实现改进时钟算法了。首先， 改进时钟算法要求所有页面形成一个环形的队列，这通过list_entry很容易进行实现；其次，由于页表项中记录了访问为和修改位，如下图所示（A为访问位，D为修改位）

```
  PFN19 ... PFN0|Reserved(3bit)|0|D|0|A|PCD|PWT|U/S|W/R|P
```
故改进时钟算法的必要条件都已经集齐。`被换出页面的特征是访问位和修改位都为0（这可能是通过多轮修改后的结果）；通过页表项的标志位可以判断页面是否被访问以及是否被修改；当发生缺页异常时，且所需页面在外存中，则需要换入；如果内存没有空闲页，则要进行扫描，如果遇到A和D位都为0的页面，那么就执行换出。`

---
##与参考答案实现上的区别
####练习一
>答案中加入了调用各种内存管理函数失败的错误处理，如get_pte和pgdir_alloc_page返回为NULL的情况

####练习二
>答案将新进入的页面放在队列的头部，换出时从尾部换出，和我的实现方法正好相反

---
##实验原理（重要部分简析）
###实验中涉及的原理
####1.虚拟内存管理
>`本次实验主要是完成虚拟内存管理的建立，在前面的实现中ucore已经完成了中断处理和物理内存的管理，这就给虚拟内存管理打下了很好的基础，虚拟内存管理主要由mm_struct/vma_struct/swap_fifo这几个重要的数据结构和算法框架组成。`从原理上说，在操作系统中，虚拟内存其实包含多个虚拟层次，在不同的层次体现了不同的作用。首先，在有了分段或分页机制后，程序员或CPU直接“看到”的地址已经不是实际的物理地址了，这已经有一层虚拟化，我们可简称为内存地址虚拟化。有了内存地址虚拟化，我们就可以通过设置段界限或页表项来设定软件运行时的访问空间，确保软件运行不越界，完成内存访问保护的功能。`实验中其实是对原理的一个具体实现，借助比较简单的机制完成了每个进程所必须的虚拟内存的管理`

####2.中断处理机制与缺页异常
>`本次实验再次涉及了中断处理，与实验一初始化中断管理和简单地处理时钟中断不同的是，这次需要更为复杂的中断处理。主要是处理缺页异常`，CPU把引起缺页异常的虚拟地址装到寄存器CR2中，并给出了出错码（tf->tf_err），指示引起缺页异常的存储器访问的类型。而中断服务例程会调用缺页异常处理函数do_pgfault进行具体处理。ucore中do_pgfault函数是完成缺页异常处理的主要函数，它根据从CPU的控制寄存器CR2中获取的缺页异常的虚拟地址以及根据 error code的错误类型来查找此虚拟地址是否在某个VMA的地址范围内以及是否满足正确的读写权限，如果在此范围内并且权限也正确，这认为这是一次合法访问，但没有建立虚实对应关系。所以需要分配一个空闲的内存页，并修改页表完成虚地址到物理地址的映射，刷新TLB，然后调用iret中断，返回到产生缺页异常的指令处重新执行此指令。如果该虚地址不再某VMA范围内，这认为是一次非法访问。

####3.页面替换算法
>在原理课上，我们讨论了很多的页面算法，比如最优替换算法、LRU替换算法、时钟替换算法、FIFO替换算法等等；也讨论了不同算法的特点。在实验中，我们主要实现了FIFO算法框架，即构建了一个链表，表头为最先访问的页面，每次需要替换页到磁盘时就从表头进行选择，`这个算法在理论上是比较低效的，而且会出现Belady现象，但作为实验来说，是一个比较不错的实践手段，因为它易于实现和调试，也方便测试。`并且在SPOC讨论中，我们也讨论了时钟算法在ucore框架下实现的可能性，应该说ucore的可拓展性还是很强的

###实验中未涉及的原理
####1.磁盘对换区
在虚拟存储管理中，能够把不常用的页面换入到外存是非常重要的一点。这就牵涉到和磁盘的交互，磁盘中应该要有一块兑换分区用来保存本该在内存中的进程的存储空间。`要实现好虚拟存储，就要实现外存的空间如何在内存中进行映射和换入换出`,在原理中这是很重要的，在实验练习中没有过多的涉及（其实ide和swapfs承担了这部分的工作，但并不是本次实验的重点）