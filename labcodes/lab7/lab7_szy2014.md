#OS Lab7 Report

##练习1:理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题
####1.内核级信号量的设计描述
>内核级信号量对外表现为一个带有资源属性和资源修改原子操作的整体，对内则表现为一个由整型变量和等待队列构成的结构体，以及基于结构体的一系列操作函数。

```
typedef struct {
    int value;
    wait_queue_t wait_queue;
} semaphore_t;
```
>其中value为这个信号量的资源量，wait_queue为等待队列，等待信号量的进程会挂在这个队列上。信号量最关键的部分是操作它的P函数和V函数，在ucore中P操作函数down(semaphore_t *sem)和V操作函数 up(semaphore_t *sem)。但这两个函数的具体实现是__down(semaphore_t *sem, uint32_t wait_state) 函数和__up(semaphore_t *sem, uint32_t wait_state)函数。

>`具体实现信号量的P操作，首先关掉中断，然后判断当前信号量的value是否大于0。如果是>0，则表明可以获得信号量，故让value减一，并打开中断返回即可；如果不是>0，则表明无法获得信号量，故需要将当前的进程加入到等待队列中，并打开中断，然后运行调度器选择另外一个进程执行。如果被V操作唤醒，则把自身关联的wait从等待队列中删除。`

>`具体实现信号量的V操作，首先关中断，如果信号量对应的wait queue中没有进程在等待，直接把信号量的value加一，然后开中断返回；如果有进程在等待且进程等待的原因是semophore设置的，则调用wakeup_wait函数将waitqueue中等待的第一个wait删除，且把此wait关联的进程唤醒，最后开中断返回`

####2.基于内核级信号量的哲学家就餐问题的执行流程
>与在线课程中介绍的不同（MOOC课程中将五把叉子作为五个信号量来处理），ucore中基于信号量的哲学家问题以哲学家作为信号量，把一个哲学家周围的两把叉子作为一个整体来考虑，要不就是能够全部获取进餐，要不就挂起等待。首先创建五个哲学家进程，把五个哲学家信号量初始化为0，即它作为一个同步事件来处理。哲学家首先进入思考状态，然后休眠一段时间，之后哲学家会进入临界区，并尝试获取两边的叉子，如果能获取就对自身的信号量作up操作，表示同步条件已经完成；如果不能获取（即两边至少有一个哲学家在进餐），就退出，然后因为同步事件未完成而被down挂起。如果进餐完毕，则哲学家释放自身的叉子，并测试两边的哲学家是否能够进餐。

####3.用户态进程/线程提供信号量机制的设计方案
>内核信号量和用户态信号量最大的差别就是处理权限问题，在内核信号量的实现过程中，有很多需要内核级别权限才能执行的操作，包括通过关闭中断来实现P、V原子操作以及对进程控制块的调度操作等等。故最简单的设计方式就是在用户态包装一些必要的操作，比如up\down，将其作为系统调用提供给用户态来调用。其次的问题是内存共享的问题，在内核态，所有线程的内存空间都是相同的，故对于一个信号量的访问和操作在语义和实际上都是针对同一个信号量；而在用户态则不同，不同的用户进程之间是不共享虚拟空间的，如果在fork时将信号量的那部分内存也复制了的话就没有意义了，故使用信号量进行同步互斥的进程之间，除了本身需要共享的一部分内存外，信号量的那部分内存也需要共享，即要求用户在初始化信号量时系统重新分配一个页面，并把这个页面设置为共享，fork时不要重新复制。

---
##练习2：完成内核级条件变量和基于内核级条件变量的哲学家就餐问题
####1.内核级条件变量的设计描述
>内核级条件变量主要由三部分组成，核心部分是一个信号量，其次是记录等待此条件的进程个数，最后是一个指向从属管程的指针，如下所示

```
typedef struct condvar{
    semaphore_t sem;       
    int count;              // the number of waiters on condvar
    monitor_t * owner;      // the owner(monitor) of this condvar
} condvar_t;
```
>针对条件变量，有两个基本的操作cond_wait和cond_signal，顾名思义wait就是等待这个条件成立，而signal就是确认条件成立，并提醒那些等待着这个条件的进程可以醒来了。

>简单分析一下cond_wait函数，`进程肯定要等待一个条件变量成立才能执行，那么自身需要挂起并让另一个进程来运行管程的函数，此时有两种情况，第一是原先已经有在管程中的进程，只是因为signal而挂起了，那么wait函数需要唤醒它们；第二种情况是没有因为signal而挂起的函数，那么wait就需要释放管程的互斥锁，让其他需要进入的进程执行管程代码。`

>`再看cond_signal函数，它要做就是唤醒等待这个条件变量的进程，如果没有人在等待，那么就直接返回即可。`

####2.用户态进程/线程提供条件变量机制的设计方案
>条件变量是基于信号量来实现的，底层的操作其实最后都落实到信号量的PV操作上，在前面提到的信号量的实现基础上，条件变量只是多了一层封装而已，同样需要考虑的是在创建条件变量的时候需要共享内存，这点也是和内核级别实现上的最大区别。

---
##与参考答案实现上的区别
####练习二
>没有太大的区别

---
##实验原理（重要部分简析）
###实验中涉及的原理
####1.信号量
>信号量是一种同步互斥机制的实现，普遍存在于现在的各种操作系统内核里。相对于spinlock 的应用对象，信号量的应用对象是在临界区中运行的时间较长的进程。等待信号量的进程需要睡眠来减少占用 CPU 的开销，当多个（>1）进程可以进行互斥或同步合作时，一个进程会由于无法满足信号量设置的某条件而在某一位置停止，直到它接收到一个特定的信号（表明条件满足了）。为了发信号，需要使用一个称作信号量的特殊变量。为通过信号量s传送信号，信号量的V操作采用进程可执行原语semSignal(s)；为通过信号量s接收信号，信号量的P操作采用进程可执行原语semWait(s)；如果相应的信号仍然没有发送，则进程被阻塞或睡眠，直到发送完为止

####2.条件变量与管程
>引入了管程是为了将对共享资源的所有访问及其所需要的同步操作集中并封装起来。Hansan为管程所下的定义：“一个管程定义了一个数据结构和能为并发进程所执行（在该数据结构上）的一组操作，这组操作能同步进程和改变管程中的数据”。局限在管程中的数据结构，只能被局限在管程的操作过程所访问，任何管程之外的操作过程都不能访问它；另一方面，局限在管程中的操作过程也主要访问管程内的数据结构。由此可见，管程相当于一个隔离区，它把共享变量和对它进行操作的若干个过程围了起来，所有进程要访问临界资源时，都必须经过管程才能进入，而管程每次只允许一个进程进入管程，从而需要确保进程之间互斥。

>`一个条件变量CV可理解为一个进程的等待队列，队列中的进程正等待某个条件C变为真。每个条件变量关联着一个断言 "断言 (程序)")Pc。当一个进程等待一个条件变量，该进程不算作占用了该管程，因而其它进程可以进入该管程执行，改变管程的状态，通知条件变量CV其关联的断言Pc在当前状态下为真。`