#OS Lab4 Report

##练习1：分配并初始化一个进程控制块
####1.设计思路
>主要需要完成的是proc_struct这个基本的进程控制块的初始化工作，对这个结构体中的每一个成员进行初始化操作，一般是赋值为0或者空指针，有些特殊的域需要特别处理（cr3）

####2.实现过程

```
		proc->state = PROC_UNINIT;
    	proc->pid = -1;
    	proc->runs = 0;
    	proc->kstack = 0;
    	proc->need_resched = 0;
    	proc->parent = NULL;
    	proc->mm = NULL;
    	struct context nullContext;
    	memset(&nullContext, 0, sizeof(struct context));
    	proc->context = nullContext;
    	proc->tf = NULL;
    	proc->cr3 = boot_cr3;
    	proc->flags = 0;
    	memset(proc->name, 0, sizeof(proc->name));
```
 
 
####3.请说明proc_struct中struct context context和struct trapframe *tf成员变量含义和在本实验中的作用是啥
>先说使用情况更为广泛的trapframe, trapframe叫做异常帧，是保存在内核堆栈上的进程上下文信息。在中断、异常或者系统调用的时候，会由硬件和软件协同来保存这个数据结构，这个结构如下所示

```
struct trapframe {
struct pushregs tf_regs;
uint16_t tf_gs;
uint16_t tf_padding0;
uint16_t tf_fs;
uint16_t tf_padding1;
uint16_t tf_es;
uint16_t tf_padding2;
uint16_t tf_ds;
uint16_t tf_padding3;
uint32_t tf_trapno;
/* below here defined by x86 hardware */
uint32_t tf_err;
uintptr_t tf_eip;
uint16_t tf_cs;
uint16_t tf_padding4;
uint32_t tf_eflags;
/* below here only when crossing rings, such as from user to kernel */
uintptr_t tf_esp;
uint16_t tf_ss;
uint16_t tf_padding5;
} __attribute__((packed));
```
其中，有一部分是由硬件直接保存的(error code及以下)，并且还会根据中断时所在的特权级选择性保存ss和esp，有一部分是通过软件来保存的（主要为段寄存器和通用寄存器），总的来说，trapframe描述了一个进程在正常执行逻辑中的上下文信息，对进程是不透明的。`在本实验中，trapframe主要用来模拟线程的执行环境，在创建完线程之后需要执行这个线程时，需要通过一个中断的返回，trapframe在这个时候就起到了很关键的作用，它的正确与否决定了新建的线程能否正确地执行。`

而context则不同，乍一看它的结构和trapframe中的tf_regs差不多

```
struct context {
uint32_t eip;
uint32_t esp;
uint32_t ebx;
uint32_t ecx;
uint32_t edx;
uint32_t esi;
uint32_t edi;
uint32_t ebp;
};
```
但context保存的是进程在中断服务例程（或者异常系统调用例程）中执行的上下文信息，在lab4中，context保存的是在proc_run这个函数中执行的现场信息，这个函数里面有一个switch_to，在这里保存了context，这就意味着context对于进程是透明的，进程以为自己进入了服务例程之后就直接恢复了，其实可能并不是这样，在其中可能被调度过，调度时需要保存的就是context。

---
##练习2：为新创建的内核线程分配资源
####1.设计思路
>主要需要完成的是do_fork函数，这个函数的作用是给新建的线程分配一系列的资源，包括进程控制块、内存资源、堆栈资源、管理信息和标识号等等。通过ucore自身提供的一些接口函数可以实现资源的分配，同时需要做一些异常处理。

####2.实现过程
 1. 调用alloc_proc，首先获得一块用户信息块（可能出错）
 2. 为进程分配一个内核栈setup_kstack（可能出错）
 3. 复制原进程的内存管理信息到新进程copy_mm（可能出错，但在本实验不可能）
 4. 复制原进程上下文到新进程copy_thread
 5. 将新进程添加到进程列表list_add/hash_proc
 6. 唤醒新进程wakeup_proc
 7. 返回新进程号get_pid
 
####3.请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由
>ucore可以做到给每个新的线程一个唯一的id（在线程数没有超过最大进程数的前提下），因为ucore中定义的最大pid是大于最大线程数的，而get_pid采用轮询的方式查找当前没有被用到的pid，故应该能够做到分配唯一的id。

---

##练习3：阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的
####1.proc_run函数分析
>proc_run主要完成了两个进程的上下文切换，这个切换包括当前进程的控制块的切换、进程页表和内核堆栈的切换以及进程的通用寄存器（即上下文）的保存于恢复。`首先，这个过程应该是原子操作，因为其中涉及到寄存器的恢复，故proc_run屏蔽了一般的中断`；首先切换了当前进程的控制块，然后切换了新进程的内核堆栈，之后加载了新的页表，最后进行上下文的切换。

####2.在本实验的执行过程中，创建且运行了几个内核线程？
>在本实验中，创建并运行了两个内核线程，分别是idle和init

####3.语句local_intr_save(intr_flag);....local_intr_restore(intr_flag);在这里有何作用?请说明理由
>这两句语句在这里是屏蔽中断的作用，把这两句宏展开到最底层，可以发现是关闭中断和打开中断的系统调用cli和sti。因为进程上写文切换时牵涉到通用寄存器的保存和恢复，如果被中断打断会造成不可预知的错误。

---
##与参考答案实现上的区别
####练习一
>基本没有太大区别

####练习二
>答案的实现加入了一部分原子操作，即在将新进程加入进程队列中时不允许中断

---
##实验原理（重要部分简析）
###实验中涉及的原理
####1.进程的属性
>进程的定义：一个具有一定独立功能的程序在一个数据集合上的一次动态执行过程。这里有四个关键词：程序、数据集合、执行、动态执行过程。从CPU的角度来看，所谓程序就是一段特定的指令机器码序列而已。CPU会一条一条地取出在内存中程序的指令并按照指令的含义执行各种功能。所谓数据集合就是使用的内存，所谓执行就是让CPU工作。那么这个数据集合和执行其实体现了进程对资源的占用。动态执行过程体现了程序执行的不同“生命”阶段：诞生、工作、休息/等待、死亡。如果这一段指令执行完毕，也就意味着进程结束了。`对应到实验中，ucore需要设计一个数据结构来表示进程（或者线程）的这些所有的属性，那就是进程控制块proc_struct,控制块中就包含了进程的各个属性`其中比较重要的几个域如下

```
mm ：内存管理的信息，包括内存映射列表、页表指针等。mm里有个很重要的项pgdir，记录的是该进程使用的一级页表的物理地址。

state：进程所处的状态

context：进程的上下文，用于进程切换（参见switch.S）。在 ucore 中，所有的进程在内核中也是相对独立的（例如独立的内核堆栈以及上下文等等）。使用 context 保存寄存器的目的就在于在内核态中能够进行上下文之间的切换。实际利用context进行上下文切换的函数是switch_to，在kern/process/switch.S中定义。

tf：中断帧的指针，总是指向内核栈的某个位置：当进程从用户空间跳到内核空间时，中断帧记录了进程在被中断前的状态。
```

####2.进程的三状态模型
>用户进程有不同的状态（也可理解为“生命”的不同阶段），当操作系统把程序的放到内存中后，这个进程就“诞生”了，不过还没有开始执行，但已经消耗了内存资源，处于“创建”状态；当进程准备好各种资源，就等能够使用CPU时，进程处于“就绪”状态；当进程终于占用CPU，程序的指令被CPU一条一条执行的时候，这个进程就进入了“工作”状态，也称“运行”状态，这时除了进一步占用内存资源外，还占用了CPU资源；当这个进程等待某个资源而无法继续执行时，进程可放弃CPU使用，即释放CPU资源，进入“等待”状态；当程序指令执行完毕，进程进入了“死亡”状态。`在ucore中，也对这几种状态作了描述，即proc_struct中的state，但ucore又做了一定的简化，即运行态和就绪态用同一种状态来表示，具体的状态如下`

```
process state: meaning               -- reason
PROC_UNINIT  : uninitialized    -- alloc_proc
PROC_SLEEPING: sleeping -- try_free_pages, do_wait, do_sleep
PROC_RUNNABLE: runnable(maybe running)-- proc_init, wakeup_proc, 
PROC_ZOMBIE  :   almost dead             -- do_exit
```

####3.进程与线程
>一个进程拥有一个存放程序和数据的的虚拟地址空间以及其他资源。一个进程基于程序的指令流执行，其执行过程可能与其它进程的执行过程交替进行。因此，`一个具有执行状态（运行态、就绪态等）的进程是一个被操作系统调度并分派的单位`。在大多数操作系统中，这两个特点是进程的主要本质特征。但`这两个特征相对独立`，操作系统可以把这两个特征分别进行管理。`这样可以把拥有资源所有权的单位通常仍称作进程，对资源的管理成为进程管理；把指令执行流的单位称为线程，对线程的管理就是线程调度和线程分派`。对属于同一进程的所有线程而言，这些线程共享进程的虚拟地址空间和其他资源，但每个线程都有一个独立的栈，还有独立的线程运行上下文用于包含表示线程执行现场的寄存器值等信息。`在ucore中，进程和线程在表示形式上基本没有任何区别，这个体现在进程控制块和线程控制块是同一种数据结构，它们最本质的区别就是它们的内存映射是不是和其他进程或者线程所共享，因为线程之间是共享内存映射的。`

###实验中未涉及的原理
####1.进程的内存资源的分配
>一个进程在执行时需要自己的内存资源（因为进程是资源分配的单位），这种处理方式也保证了进程之间内存的保护与隔离。故进程在创建之后，操作系统需要为其分配内存资源并建立好页表。在本实验中，我们创建了两个内核进程（线程），他们和ucore内核都是共享内存地址空间的。故我们简单地使用了boot_cr3，没有做复杂的分配工作。
